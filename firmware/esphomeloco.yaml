substitutions:
  device_name: !secret device_name 
  device_ip: !secret device_ip

esphome:
  name: ${device_name}

esp8266:
  board: esp01_1m
  restore_from_flash: true

preferences:
  flash_write_interval: 10s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: ${device_ip}
    gateway: !secret device_gateway
    subnet: !secret device_subnet
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret fallback_wifi_ssid
    password: !secret fallback_wifi_password

logger:
  
api:
  reboot_timeout: 15min
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

# the web_server & sensor components can be removed without affecting core functionaility.

web_server:
  port: 80

sensor:
  - platform: wifi_signal
    name: ${device_name} Wifi Signal Strength
    update_interval: 60s
  - platform: uptime
    name: ${device_name} Uptime

#######################################
# Device specific Config Begins Below #
#######################################

# --- Définition des sorties (outputs) ---
output:
  # Broche vitesse (PWM)
  - platform: esp8266_pwm
    id: motor_speed
    pin: GPIO3
    frequency: 5000 Hz

# --- Direction via L293D ---
switch:
  # ON/OFF  général moteur (exposé à HA)
  - platform: template
    id: motor_enable
    name: "${device_name} Motor ON/OFF"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - logger.log: "Motor enabled"
    turn_off_action:
      - logger.log: "Motor disabled"
      - output.set_level:
          id: motor_speed
          level: 0
      - switch.turn_off: in1_dir
      - switch.turn_off: in2_dir

  # Broches direction du L293D (IN1 / IN2)
  - platform: gpio
    id: in1_dir
    pin:
      number: GPIO0
      mode: OUTPUT
    name: "${device_name} dir1"
    internal: true

  - platform: gpio
    id: in2_dir
    pin:
      number: GPIO2
      mode: OUTPUT
    name: "${device_name} dir2"
    internal: true


number:
  # Vitesse minimale pour que la loco commence à bouger
  - platform: template
    name: "Vitesse minimale pour bouger (donnée persistante)"
    id: min_speed_to_move
    min_value: 1
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 20

  # Sélecteur 1 : vitesse bidirectionnelle simple (-100 .. 100)
  - platform: template
    name: "Vitesse bidirectionnelle sans prise en compte du minimum pour bouger"
    id: normal_speed
    min_value: -100
    max_value: 100
    step: 1
    optimistic: true
    initial_value: 0
    set_action:
      - lambda: |-
          // Quand on utilise ce sélecteur, on remet l'autre à 0
          id(assisted_speed).publish_state(0);

          // Si le moteur est OFF, on ignore et on force l'arrêt
          if (!id(motor_enable).state) {
            id(motor_speed).set_level(0);
            id(in1_dir).turn_off();
            id(in2_dir).turn_off();
            return;
          }

          float v = x; // -100 .. 100

          if (v > 0.0f) {
            // Marche avant
            id(in1_dir).turn_on();
            id(in2_dir).turn_off();
          } else if (v < 0.0f) {
            // Marche arrière
            id(in1_dir).turn_off();
            id(in2_dir).turn_on();
          } else {
            // Arrêt / roue libre
            id(in1_dir).turn_off();
            id(in2_dir).turn_off();
          }

          float duty = fabsf(v) / 100.0f; // 0..1
          id(motor_speed).set_level(duty);

  # Sélecteur 2 : vitesse assistée (toujours >= min_speed_to_move si ≠ 0)
  - platform: template
    name: "Vitesse bidirectionnelle avec prise en compte du minimum pour bouger"
    id: assisted_speed
    min_value: -100
    max_value: 100
    step: 1
    optimistic: true
    initial_value: 0
    set_action:
      - lambda: |-
          // Quand on utilise ce sélecteur, on remet le normal à 0
          id(normal_speed).publish_state(0);

          // Si le moteur est OFF, on ignore et on force l'arrêt
          if (!id(motor_enable).state) {
            id(motor_speed).set_level(0);
            id(in1_dir).turn_off();
            id(in2_dir).turn_off();
            return;
          }

          float v = x; // -100 .. 100

          if (v == 0.0f) {
            // Arrêt
            id(motor_speed).set_level(0);
            id(in1_dir).turn_off();
            id(in2_dir).turn_off();
            return;
          }

          // Direction en fonction du signe
          if (v > 0.0f) {
            // Marche avant
            id(in1_dir).turn_on();
            id(in2_dir).turn_off();
          } else {
            // Marche arrière
            id(in1_dir).turn_off();
            id(in2_dir).turn_on();
          }

          float percent = fabsf(v); // 0..100
          float minp = id(min_speed_to_move).state; // 1..100

          if (minp < 0.0f) minp = 0.0f;
          if (minp > 100.0f) minp = 100.0f;

          // On remappe la vitesse choisie dans [minp .. 100]
          // percent = 0   -> 0 (mais on ne vient pas ici, v==0 est traité plus haut)
          // percent = 100 -> 100%
          float outp = minp + (percent / 100.0f) * (100.0f - minp);

          float duty = outp / 100.0f; // 0..1
          id(motor_speed).set_level(duty);
